Main Problems & Solutions:
1. Harmonic Rolloff Model is Too Simplified
Problem: Your exp(-n/(brightness*6)) model doesn't match real instrument physics well. Real instruments have more complex harmonic relationships.

Research-backed improvement:

javascript
/**
 * Improved harmonic amplitude based on real piano string research
 * Models: 
 * - Base rolloff: exp(-n * Î±)
 * - Velocity effect: increases high harmonic content for higher velocities
 * - Odd/even harmonic differences (for square wave simulation)
 */
function calculateHarmonicRolloff(harmonicNumber, velocity) {
    if (typeof window !== 'undefined' && window.physicsSettings && !window.physicsSettings.velocityTimbre) {
        return Math.exp(-harmonicNumber * 0.15); // Gentler rolloff
    }
    
    const vNorm = velocity / 127.0;
    const brightness = 1.0 + 0.5 * Math.pow(vNorm, 0.7);
    
    // More realistic model based on piano string research:
    // 1. Base exponential decay
    const baseRolloff = Math.exp(-harmonicNumber * 0.15);
    
    // 2. Velocity-dependent boost for higher harmonics (research shows this happens)
    const velocityBoost = 1.0 + (vNorm * 0.3 * Math.exp(-harmonicNumber / 10));
    
    // 3. Account for oscillator type (odd harmonics for square waves)
    const oscillatorType = getOscillatorTypeForVelocity(velocity);
    let harmonicFactor = 1.0;
    
    if (oscillatorType === 'square') {
        // Square waves: only odd harmonics, stronger rolloff
        if (harmonicNumber % 2 === 0) return 0; // Even harmonics = 0
        harmonicFactor = 1.0 / harmonicNumber; // 1/n rolloff for square waves
    }
    
    return baseRolloff * velocityBoost * harmonicFactor * (1.0 + vNorm * 0.2);
}
2. Oscillator Type Switching is Too Abrupt
Problem: Hard switches between sine/triangle/square create unnatural timbre jumps.

Better approaches:

javascript
/**
 * Gradual timbre transitions using additive synthesis or wave shaping
 */
function getOscillatorTypeForVelocity(velocity) {
    if (typeof window !== 'undefined' && window.physicsSettings) {
        if (!window.physicsSettings.velocityTimbre) return 'sine';
        
        // Option 1: Wave shaping continuum (best for smoothness)
        if (window.physicsSettings.advancedTimbre) {
            return 'custom'; // Use custom wave shaping
        }
    }
    
    const vNorm = velocity / 127.0;
    
    // Smoother transitions with blending zones
    if (vNorm < 0.3) {
        return 'sine';
    } else if (vNorm < 0.5) {
        // Blend sine -> triangle in this range
        return Math.random() < (vNorm - 0.3) / 0.2 ? 'triangle' : 'sine';
    } else if (vNorm < 0.8) {
        return 'triangle';
    } else if (vNorm < 0.95) {
        // Blend triangle -> square in this range
        return Math.random() < (vNorm - 0.8) / 0.15 ? 'square' : 'triangle';
    } else {
        return 'square';
    }
}

// BETTER: Create custom waveform that evolves with velocity
function createDynamicWaveform(velocity, context) {
    const vNorm = velocity / 127.0;
    const real = new Float32Array(4096);
    const imag = new Float32Array(4096);
    
    // Start with sine wave
    real[1] = 1.0; // Fundamental at bin 1
    
    // Add harmonics based on velocity
    const maxHarmonics = Math.floor(1 + vNorm * 20); // Up to 21 harmonics for loudest
    
    for (let n = 2; n <= maxHarmonics; n++) {
        // Realistic harmonic amplitude model
        let amplitude;
        
        if (vNorm < 0.3) {
            // Soft: gentle rolloff
            amplitude = Math.exp(-n * 0.25);
        } else if (vNorm < 0.7) {
            // Medium: piano-like spectrum
            amplitude = Math.exp(-n * 0.15) * (1.0 + 0.3 * vNorm);
        } else {
            // Loud: brighter with some inharmonicity simulation
            const inharmonicity = 1.0 + 0.001 * n * n * vNorm;
            amplitude = Math.exp(-n * 0.12) * (1.0 + 0.5 * vNorm) / inharmonicity;
        }
        
        // Apply velocity brightness
        amplitude *= (1.0 + 0.4 * Math.pow(vNorm, 0.8));
        
        real[n] = amplitude;
    }
    
    const wave = context.createPeriodicWave(real, imag, {disableNormalization: true});
    return wave;
}
3. Missing Dynamic Elements
Problem: Real instruments have velocity-dependent:

Attack time (faster attack for higher velocity)

Harmonic evolution over time (brightness changes during note)

Add these functions:

javascript
/**
 * Velocity-dependent attack time
 * Research: higher velocity = faster attack
 */
function getAttackTimeForVelocity(velocity) {
    const vNorm = velocity / 127.0;
    // Higher velocity = faster attack (0.01s to 0.2s range)
    return 0.01 + (1.0 - vNorm) * 0.19;
}

/**
 * Time-varying brightness (harmonic content evolves during note)
 */
function getTimeVaryingBrightness(velocity, timeSinceAttack) {
    const vNorm = velocity / 127.0;
    const attackTime = getAttackTimeForVelocity(velocity);
    
    if (timeSinceAttack < attackTime) {
        // During attack: brightness peaks
        const attackProgress = timeSinceAttack / attackTime;
        return 1.0 + 0.3 * Math.sin(attackProgress * Math.PI) * vNorm;
    } else {
        // After attack: gradual decay of brightness
        const decayTime = 0.5 + (1.0 - vNorm) * 2.0; // Louder = longer decay
        const decayProgress = Math.min(1.0, (timeSinceAttack - attackTime) / decayTime);
        return 1.0 + 0.2 * (1.0 - decayProgress) * vNorm;
    }
}
4. Practical Implementation Improvements
javascript
// Complete improved module
class VelocityTimbreManager {
    constructor(audioContext) {
        this.context = audioContext;
        this.sampleRate = audioContext.sampleRate;
        this.waveCache = new Map(); // Cache dynamic waveforms
    }
    
    getDynamicOscillator(velocity, frequency) {
        const vNorm = velocity / 127.0;
        const key = `${Math.round(vNorm * 10)}-${Math.round(frequency)}`;
        
        if (!this.waveCache.has(key)) {
            this.waveCache.set(key, this.createDynamicWaveform(velocity));
        }
        
        const osc = this.context.createOscillator();
        osc.setPeriodicWave(this.waveCache.get(key));
        osc.frequency.value = frequency;
        
        return osc;
    }
    
    createDynamicWaveform(velocity) {
        // Implementation as above, but with caching
        // ... (use the improved createDynamicWaveform function)
    }
    
    // Add filter modulation based on velocity
    getFilterSettings(velocity) {
        const vNorm = velocity / 127.0;
        return {
            type: 'lowpass',
            frequency: 20000 * (0.3 + 0.7 * vNorm), // Brighter = higher cutoff
            Q: 1.0,
            gain: 0
        };
    }
}

// Export the improved version
if (typeof window !== 'undefined') {
    window.VelocityTimbreManager = VelocityTimbreManager;
    // Keep backwards compatibility
    window.calculateBrightnessIndex = calculateBrightnessIndex;
    window.calculateHarmonicRolloff = calculateHarmonicRolloff;
    window.getOscillatorTypeForVelocity = getOscillatorTypeForVelocity;
    window.getAttackTimeForVelocity = getAttackTimeForVelocity;
}
Key Research-Based Improvements:
Smooth harmonic evolution instead of abrupt oscillator switching

Time-varying brightness - harmonics change during the note

Velocity-dependent attack characteristics

Proper harmonic rolloff models from piano/string research

Waveform caching for performance

Filter modulation to complement harmonic changes

These changes will make your timbre modulation sound much more natural and musical, less like "switching between presets" and more like a real instrument responding to playing dynamics